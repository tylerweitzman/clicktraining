<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Click the Target Game</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            font-family: Arial, sans-serif;
            color: white;
        }

        #gameArea {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #topBar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            font-size: 24px;
        }

        #hitCounter {
            margin-right: 20px;
        }

        #timeCounter {
            margin-left: 20px;
        }

        .target {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            cursor: pointer;
            transition: opacity 0.3s;
        }

        .target.current {
            background-color: red;
        }

        .target.next {
            background-color: blue;
            opacity: 0;
        }

        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .btn {
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 5px;
        }

        .input {
            margin-top: 10px;
            padding: 5px;
            font-size: 16px;
            width: 200px;
            text-align: center;
        }

        #graph {
            width: 100%;
            max-width: 600px;
            height: 300px;
        }
    </style>
</head>

<body>
    <div id="gameArea"></div>
    <div id="topBar">
        <div id="hitCounter">Hits: 0</div>
        <div id="timeCounter">Time: 10</div>
    </div>
    <div id="controls" class="modal">
        <div id="result"></div>
        <button id="restartBtn" class="btn">Restart</button>
        <input id="seedInput" type="text" value="2332" placeholder="Enter Seed" class="input">
        <input id="minDistanceInput" type="number" placeholder="Min Distance (optional)" class="input">
        <input id="maxDistanceInput" type="number" placeholder="Max Distance (optional)" class="input">
    </div>
    <div id="pauseMessage" class="modal">Game Paused. Return to fullscreen to resume.</div>
    <div id="stats" class="modal">
        <div id="statsContent"></div>
        <canvas id="graph"></canvas>
        <button id="submitBtn" class="btn">Submit to Leaderboard</button>
    </div>

    <script>
        (() => {
            const $ = id => document.getElementById(id);
            const random = seed => Math.sin(seed++) * 10000 % 1;

            let state = {
                score: 0,
                timeLeft: 10,
                seed: 2332,
                gameSpeed: 1000,
                hitData: [],
                playerName: "Tyler",
                currentTarget: null,
                nextTarget: null,
                startTime: null,
                timeInterval: null,
                gameActive: false
            };

            const getRandomPosition = (seed, minDistance, maxDistance) => {
                let attempts = 0, x, y, distance;
                do {
                    x = random(seed) * (innerWidth - 30);
                    y = random(seed + 1) * (innerHeight - 30);
                    distance = state.currentTarget ? Math.hypot(x - state.currentTarget.x, y - state.currentTarget.y) : 0;
                    seed += 2;
                    attempts++;
                } while (attempts < 100 &&
                    ((minDistance && distance < minDistance) ||
                        (maxDistance && distance > maxDistance)));
                return { x, y };
            };

            const createTarget = (isNext = false) => {
                const minDistance = $('minDistanceInput').value ? +$('minDistanceInput').value : undefined;
                const maxDistance = $('maxDistanceInput').value ? +$('maxDistanceInput').value : undefined;
                const { x, y } = getRandomPosition(state.seed, minDistance, maxDistance);
                state.seed += 2;
                const target = Object.assign(document.createElement('div'), {
                    className: `target ${isNext ? 'next' : 'current'}`,
                    style: `left:${x}px;top:${y}px`,
                    onclick: e => {
                        e.stopPropagation();
                        if (state.gameActive && !isNext) recordHit(x, y);
                    }
                });
                $('gameArea').appendChild(target);
                return { x, y, element: target };
            };

            const recordHit = (x, y) => {
                const timeTaken = performance.now() - state.startTime;
                const distance = Math.hypot(state.currentTarget.x - x, state.currentTarget.y - y);
                state.hitData.push({ time: timeTaken, distance });
                $('hitCounter').textContent = `Hits: ${++state.score}`;
                new Audio('hit.wav').play().catch(console.error);

                // Remove current target
                state.currentTarget.element.remove();

                // Make next target current
                if (state.nextTarget) {
                    state.currentTarget = state.nextTarget;
                    state.currentTarget.element.classList.remove('next');
                    state.currentTarget.element.classList.add('current');
                    state.nextTarget = null;
                } else {
                    state.currentTarget = createTarget();
                }

                state.startTime = performance.now();
            };

            const startGame = () => {
                document.documentElement.requestFullscreen().catch(console.error);
                resetGame();
                state.gameActive = true;
                state.timeInterval = setInterval(() => {
                    $('timeCounter').textContent = `Time: ${--state.timeLeft}`;
                    if (state.timeLeft <= 0) endGame();
                }, state.gameSpeed);
                state.currentTarget = createTarget();
                state.startTime = performance.now();
            };

            const resetGame = () => {
                clearInterval(state.timeInterval);
                Object.assign(state, {
                    score: 0,
                    timeLeft: 10,
                    hitData: [],
                    currentTarget: null,
                    nextTarget: null,
                    gameActive: false
                });
                ['controls', 'pauseMessage', 'stats'].forEach(id => $(id).style.display = 'none');
                $('timeCounter').textContent = `Time: ${state.timeLeft}`;
                $('hitCounter').textContent = 'Hits: 0';
                $('gameArea').innerHTML = '';
            };

            const endGame = () => {
                clearInterval(state.timeInterval);
                state.gameActive = false;
                if (state.currentTarget) {
                    state.currentTarget.element.remove();
                    state.currentTarget = null;
                }
                if (state.nextTarget) {
                    state.nextTarget.element.remove();
                    state.nextTarget = null;
                }
                $('result').textContent = `You clicked ${state.score} targets!`;
                $('controls').style.display = 'flex';
                showStats();
            };

            const showStats = () => {
                const totalTime = state.hitData.reduce((sum, { time }) => sum + time, 0);
                const avgTime = totalTime / state.hitData.length;
                const fastestTime = Math.min(...state.hitData.map(({ time }) => time));
                const slowestTime = Math.max(...state.hitData.map(({ time }) => time));
                const avgDistance = state.hitData.reduce((sum, { distance }) => sum + distance, 0) / state.hitData.length;

                $('statsContent').innerHTML = `
                <p>Targets: ${state.hitData.length} in ${10 - state.timeLeft}s</p>
                <p>Area: ${innerWidth}x${innerHeight}</p>
                <p>Avg: ${avgTime.toFixed(2)}ms | ${(60000 / avgTime).toFixed(2)} TPM</p>
                <p>Fast: ${fastestTime.toFixed(2)}ms | ${(60000 / fastestTime).toFixed(2)} TPM</p>
                <p>Slow: ${slowestTime.toFixed(2)}ms | ${(60000 / slowestTime).toFixed(2)} TPM</p>
                <p>Dist: ${avgDistance.toFixed(2)}px</p>
            `;

                new Chart($('graph').getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: state.hitData.map((_, i) => i + 1),
                        datasets: [{
                            label: 'Hit Time (ms)',
                            data: state.hitData.map(({ time }) => time),
                            borderColor: 'rgba(75,192,192,1)',
                            backgroundColor: 'rgba(75,192,192,0.2)',
                            fill: false
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });

                $('stats').style.display = 'flex';
            };

            const togglePause = isPaused => {
                clearInterval(state.timeInterval);
                state.gameActive = !isPaused;
                $('pauseMessage').style.display = isPaused ? 'flex' : 'none';
                if (!isPaused) {
                    state.timeInterval = setInterval(() => {
                        $('timeCounter').textContent = `Time: ${--state.timeLeft}`;
                        if (state.timeLeft <= 0) endGame();
                    }, state.gameSpeed);
                }
            };

            $('restartBtn').onclick = () => {
                state.seed = parseInt($('seedInput').value, 10);
                startGame();
            };

            $('submitBtn').onclick = () => {
                console.log("Leaderboard:", {
                    name: state.playerName,
                    score: state.score,
                    seed: state.seed,
                    resolution: `${innerWidth}x${innerHeight}`,
                    minDistance: $('minDistanceInput').value || "Not Set",
                    maxDistance: $('maxDistanceInput').value || "Not Set"
                });
                $('stats').style.display = 'none';
            };

            $('gameArea').onclick = e => {
                if (e.target === $('gameArea') && state.gameActive) {
                    new Audio('miss.wav').play().catch(console.error);
                }
            };

            $('gameArea').onmousemove = e => {
                if (state.gameActive && state.currentTarget && !state.nextTarget) {
                    const distance = Math.hypot(e.clientX - state.currentTarget.x, e.clientY - state.currentTarget.y);
                    if (distance <= 200) {
                        state.nextTarget = createTarget(true);
                        state.nextTarget.element.style.opacity = '0.5';
                    }
                }
            };

            document.onfullscreenchange = () => togglePause(!document.fullscreenElement);
            document.onvisibilitychange = () => document.visibilityState === 'hidden' && togglePause(true);

            endGame();  // Initial state is the end screen
        })();
    </script>
</body>

</html>